<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Pilot network evolution</title>
</head>
<body>

<script src="drawing.js"></script>
<script src="vec2.js"></script>
<script src="random.js"></script>
<script src="worldmodel.js"></script>
<script src="visualizer.js"></script>
<script src="mouse.js"></script>
<script src="neurallayer.js"></script>
<script src="neuralnet.js"></script>
<script src="pilotnet.js"></script>
<script src="neuralpilot.js"></script>

<script src="fitnessgraph.js"></script>
<script src="population.js"></script>

<canvas id="canvas" width="1024" height="100"></canvas>
<br>
<div id="RUNING_TIME_TEXT"></div><br>
<div id="PROGRESS_TEXT"></div><br>
<button onclick="onRestartButton()">Restart</button>
<br>
Population size: <input type="number" id="ID_POP_SIZE" min="0" value="500"><br>
<br>
Mutation spread: <input type="number" id="ID_MUTATION_SPREAD" min="0" value="25"><br>
Mutation half-life (#generations, 0 to disable): <input type="number" id="ID_MUTATION_HALFLIFE" min="0" value="100"><br>
<p id="BEST_SOLUTION">Best solution:</p>
<textarea id="BEST_SOLUTION_OUT" rows="20" cols="120">
NN definition
</textarea>
<br>
<br>

<script>

const g_start_time = new Date();

let g_pop_size = 0;
let g_mutation_spread = 0;
let g_mutation_halflife = 0;

function read_parameters() {
	g_pop_size = parseFloat(document.getElementById("ID_POP_SIZE").value);
	g_mutation_spread = parseFloat(document.getElementById("ID_MUTATION_SPREAD").value);
	g_mutation_halflife = parseFloat(document.getElementById("ID_MUTATION_HALFLIFE").value);
}
read_parameters();

///////////////////////////////////////////////////////////

// Evaluate nets for all of these start positions and velocities
// (changes every generation but is the same for all individuals in a generation)
let g_start_conditions = [];
g_start_conditions.push( { pos: new Vec2(0, 300), vel: new Vec2(0, 0) } );
g_start_conditions.push( { pos: new Vec2(300, 0), vel: new Vec2(0, 0) } );
g_start_conditions.push( { pos: new Vec2(-300, 0), vel: new Vec2(0, 0) } );
g_start_conditions.push( { pos: new Vec2(0, -300), vel: new Vec2(0, 0) } );
g_start_conditions.push( { pos: new Vec2(-300, -300), vel: new Vec2(0, 0) } );
g_start_conditions.push( { pos: new Vec2(300, 300), vel: new Vec2(0, 0) } );
g_start_conditions.push( { pos: new Vec2(-300, 300), vel: new Vec2(0, 0) } );
g_start_conditions.push( { pos: new Vec2(300, -300), vel: new Vec2(0, 0) } );

let g_current_start_condition = 0;

// Re-use these for every individual
const g_net_outputs = [0, 0];
const g_model = new WorldModel();

function makeFitness()
{
	return [0];
}

function Individual()
{
	this.fitness = makeFitness();
	this.pilotNet = makePilotNet();
}

Individual.prototype.compareIndividuals = function(a, b)
{
	for(let i = 0; i < a.fitness.length; ++i) {
		if(a.fitness[i] == b.fitness[i])
			continue;
		return a.fitness[i] - b.fitness[i];
	}
	return 0;
}

Individual.prototype.clearFitness = function()
{
	for(let i = 0; i < this.fitness.length; ++i) {
		this.fitness[i] = 0;
	}
}

Individual.prototype.fitnessToNumber = function()
{
	let sum = 0;
	for(let i = 0; i < this.fitness.length; ++i) {
		sum += this.fitness[i];
	}
	return sum;
}

Individual.prototype.mutate = function(spread)
{
	this.pilotNet.mutate(spread);
}

Individual.prototype.randomize = function()
{
	this.pilotNet.randomize();
}

Individual.prototype.copy = function(other)
{
	for(let i = 0; i < this.fitness.length; ++i) {
		this.fitness[i] = other.fitness[i];
	}

	this.pilotNet.copy(other.pilotNet);
}

function square(x) {
	return x * x;
}

function safeInvert(x) {
	return 1 / (1 + x);
}

Individual.prototype.evaluate = function()
{
	let fitness = makeFitness();
	const simulationSeconds = 10;

	// Set the start condition
	const start = g_start_conditions[g_current_start_condition];
	g_model.particle.reset( start.pos, start.vel );

	let hasHit = false;
	for(let time = 0; time < simulationSeconds * 60; ++time) {
		this.pilotNet.run( g_net_outputs, g_model );
		const accel = g_net_outputs[0];
		const rot = g_net_outputs[1];
		g_model.run( accel, rot );

		const distSq = g_model.particle.pos.lengthSq();
		const dist = Math.sqrt(distSq);
		// const velSq = g_model.particle.vel.lengthSq();
		// const vel = Math.sqrt(velSq);

		// fitness[0] *= 0.99;

		if(!hasHit) {
			if(dist < 10) {
				hasHit = true;
				break;
			}
			else {
				fitness[0] += dist;
			}
		}
	}

	for(let i = 0; i < this.fitness.length; ++i) {
		this.fitness[i] += fitness[i];
	}
}

///////////////////////////////////////////////////////////
const g_fitnessgraph = new FitnessGraph( 0, 0, canvas.width, 100 );

function makePopulation() {
	return new Population(g_pop_size, function() {return new Individual()});
}

let g_population = makePopulation();

function createStartConditions()
{
	for(let i=0; i < g_start_conditions.length; ++i) {
		const start = g_start_conditions[i];
		start.pos.randomInUnitDisk().multiplyScalar( 300 );
		start.vel.randomInUnitDisk().multiplyScalar( 10 );
	}
}

// createStartConditions();

function initBestSolution() {
	return { generation: 0, solution: new Individual() };
}

g_best_solution = initBestSolution();

let generation = 1;
window.onload = function()
{
	const canvas = document.getElementById('canvas');
	const context = canvas.getContext('2d');

	(function drawFrame () {
		window.requestAnimationFrame( drawFrame, canvas );
		context.clearRect( 0, 0, canvas.width, canvas.height );

		const endTime = new Date();
		const secondsElapsed = Math.trunc((endTime - g_start_time) / 1000);
		document.getElementById("RUNING_TIME_TEXT").innerHTML = "Running time: " + Math.trunc(secondsElapsed / 60)
			+ " min " + Math.trunc(secondsElapsed % 60) + " sec";

		document.getElementById("PROGRESS_TEXT").innerHTML = "Evaluating start condition "
			+ (g_current_start_condition + 1) + " / " + g_start_conditions.length;

		const halflife_factor = (g_mutation_halflife > 0)
			? Math.pow(2, -generation / g_mutation_halflife) : 1;
		const spread = g_mutation_spread * halflife_factor;
		// createStartConditions();

		if(g_current_start_condition == 0) {
			g_population.clearFitnesses();
		}

		g_population.evaluate();

		if(g_current_start_condition == g_start_conditions.length - 1) {
			generation += 1;

			const currentBest = g_population.evolve(spread);
			g_fitnessgraph.push( currentBest.fitnessToNumber() );

			if(generation == 2 || g_best_solution.solution.compareIndividuals(currentBest, g_best_solution.solution) < 0) {
				g_best_solution.generation = g_fitnessgraph.generation;
				g_best_solution.solution.copy(currentBest);
				document.getElementById("BEST_SOLUTION").innerHTML = "Best solution: fitness '"
					+ g_best_solution.solution.fitness.toString() + "' found at generation " + g_best_solution.generation;
				document.getElementById("BEST_SOLUTION_OUT").innerHTML = g_best_solution.solution.pilotNet.toText();
			}
		}

		g_fitnessgraph.draw( context );

		g_current_start_condition = ((g_current_start_condition + 1) % g_start_conditions.length);

	}());
}

function onRestartButton()
{
	read_parameters();
	g_fitnessgraph.clear();
	generation = 1;
	g_population = makePopulation();
	g_best_solution = initBestSolution();
}

</script>
</body>
</html>
