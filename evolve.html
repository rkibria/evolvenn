<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Pilot network evolution</title>
<style>
body {background-color: black;}

html *
{
	font-size: 1em;
	color: lightgray;
	font-family: Arial;
}

.float-left-child {
	float: left;
}

/* base css */
body {
	padding: 0px;
}
.parent {
	padding: 0px
}
.child {
	padding: 5px
}

.button {
	background-color: #303030;
	width: 150px;
	border: solid 2px lightgray;
	color: lightgray;
	padding: 5px 3px;
	text-align: center;
	text-decoration: none;
	display: inline-block;
	margin: 4px 2px;
	cursor: pointer;
}

.button1 {font-size: 16px;}

</style>
</head>
<body>

<script src="drawing.js"></script>
<script src="vec2.js"></script>
<script src="random.js"></script>
<script src="worldmodel.js"></script>
<script src="visualizer.js"></script>
<script src="mouse.js"></script>
<script src="neurallayer.js"></script>
<script src="neuralnet.js"></script>
<script src="pilotnet.js"></script>
<script src="neuralpilot.js"></script>

<script src="fitnessgraph.js"></script>
<script src="population.js"></script>

<canvas id="canvas" width="1024" height="100"></canvas>
<br>
<div id="RUNING_TIME_TEXT"></div><br>
<div id="PROGRESS_TEXT"></div><br>
<button class="button button1" onclick="onRestartButton()">Restart</button>
<br>
Population size: <input type="number" id="ID_POP_SIZE" min="0" value="500"><br>
<br>
Mutation spread: <input type="number" id="ID_MUTATION_SPREAD" min="0" value="25"><br>
Mutation half-life (#generations, 0 to disable): <input type="number" id="ID_MUTATION_HALFLIFE" min="0" value="100"><br>
<p id="BEST_SOLUTION">Best solution:</p>
<textarea id="BEST_SOLUTION_OUT" rows="5" cols="120">
NN definition
</textarea>
<br>
<canvas id="canvas2" width="800" height="800" style="border:0px;">Your browser does not support the HTML5 canvas tag.</canvas>
<br>

<script>

var CSS_COLOR_NAMES = ["White", "Red", "Green", "Blue", "Violet", "Yellow", "Pink", "Orange"];

const g_start_time = new Date();

let g_pop_size = 0;
let g_mutation_spread = 0;
let g_mutation_halflife = 0;

function read_parameters() {
	g_pop_size = parseFloat(document.getElementById("ID_POP_SIZE").value);
	g_mutation_spread = parseFloat(document.getElementById("ID_MUTATION_SPREAD").value);
	g_mutation_halflife = parseFloat(document.getElementById("ID_MUTATION_HALFLIFE").value);
}
read_parameters();

///////////////////////////////////////////////////////////

const BASE_DIST_INC = 100;

// Evaluate nets for all of these start positions and velocities
// (changes every generation but is the same for all individuals in a generation)
let g_start_conditions = [];

let g_current_start_condition = 0;

// Re-use these for every individual
const g_net_outputs = [0, 0];
const g_model = new WorldModel();

function makeFitness()
{
	return [0];
}

function Individual()
{
	this.fitness = makeFitness();
	this.pilotNet = makePilotNet();
	this.positions = [];
	this.solves = 0;
	this.hitDistance = 20;
}

Individual.prototype.compareIndividuals = function(a, b)
{
	for(let i = 0; i < a.fitness.length; ++i) {
		if(a.fitness[i] == b.fitness[i])
			continue;
		return a.fitness[i] - b.fitness[i];
	}
	return 0;
}

Individual.prototype.clearFitness = function()
{
	for(let i = 0; i < this.fitness.length; ++i) {
		this.fitness[i] = 0;
	}
	this.solves = 0;
}

Individual.prototype.fitnessToNumber = function()
{
	let sum = 0;
	for(let i = 0; i < this.fitness.length; ++i) {
		sum += this.fitness[i];
	}
	return sum;
}

Individual.prototype.mutate = function(spread)
{
	this.pilotNet.mutate(spread);
}

Individual.prototype.randomize = function()
{
	this.pilotNet.randomize();
}

Individual.prototype.copy = function(other)
{
	for(let i = 0; i < this.fitness.length; ++i) {
		this.fitness[i] = other.fitness[i];
	}

	this.pilotNet.copy(other.pilotNet);
}

function safeInvert(x) {
	const limit = 0.001;
	const d = (x < limit) ? limit : x;
	return 1 / d;
}

Individual.prototype.evaluate = function()
{
	let fitness = makeFitness();
	const simulationSeconds = 10;

	if(g_current_start_condition == 0) {
		this.positions = [];
	}

	// Set the start condition
	const start = g_start_conditions[g_current_start_condition];
	g_model.particle.reset( start.pos, start.vel, start.dir );

	const positions = [];
	let time = 0;
	const v1 = new Vec2();
	for(; time < simulationSeconds * 60; ++time) {
		this.pilotNet.run( g_net_outputs, g_model );
		const accel = g_net_outputs[0];
		const rot = g_net_outputs[1];
		g_model.run( accel, rot );

		const distSq = g_model.particle.pos.lengthSq();
		const dist = Math.sqrt(distSq);
		const velSq = g_model.particle.vel.lengthSq();
		const vel = Math.sqrt(velSq);
		const avl = Math.abs(g_model.particle.avl);

		positions.push([g_model.particle.pos.x, g_model.particle.pos.y]);

		if(dist <= this.hitDistance) {
			this.solves += 1;
			break;
		}
		else {
			// fitness[0] += (dist - this.hitDistance) + 1.0 / Math.pow(dist - this.hitDistance, 2) * 100 * safeInvert(vel);
			// fitness[0] += (dist - this.hitDistance);
			const hd = dist - this.hitDistance;
			fitness[0] += hd;
			// fitness[0] += safeInvert(hd) * avl;

			v1.copy(g_model.particle.pos).normalize();
			v1.rotate(Math.PI / 2);
			const dp = Math.abs(v1.dot(g_model.particle.dir));
			fitness[0] += hd * dp;
		}
	}
	fitness[0] *= 1 + time / 60;
	if(time == simulationSeconds * 60) {
		fitness[0] *= 2;
	}

	this.positions.push(positions);

	for(let i = 0; i < this.fitness.length; ++i) {
		this.fitness[i] += fitness[i];
	}
}

///////////////////////////////////////////////////////////
const g_fitnessgraph = new FitnessGraph( 0, 0, canvas.width, 100 );

g_visualizer = new Visualizer( null, 10, 10, 780 );

function makePopulation() {
	return new Population(g_pop_size, function() {return new Individual()});
}

let g_population = makePopulation();

function createStartConditions(count, baseDistance, varyAll=false)
{
	const startPos = new Vec2();
	const startDir = new Vec2();
	const startVel = new Vec2();

	const dirsPerPoint = 4;
	const pointsPerCircle = 10;
	const variationsPerCircle = dirsPerPoint * pointsPerCircle;

	const distance = baseDistance * (1 + Math.trunc(count / variationsPerCircle));
	startPos.setLengthAngle(distance, Math.trunc(count / dirsPerPoint) * (2 * Math.PI / pointsPerCircle) - Math.PI/2);

	startDir.setLengthAngle(1, count * (2 * Math.PI / dirsPerPoint) + Math.PI/2);

	const velVariation = 5;
	startVel.randomInUnitDisk().multiplyScalar( velVariation );

	g_start_conditions.push( { pos: startPos, vel: startVel, dir: startDir } );

	if(varyAll) {
		for(let i = 0; i < g_start_conditions.length; ++i) {
			const variation = Math.sqrt(distance) / 2;
			g_start_conditions[i].pos.addComponents(getRandomInt(-variation, variation), getRandomInt(-variation, variation));
			g_start_conditions[i].vel.randomInUnitDisk().multiplyScalar( velVariation );
		}
	}
}

createStartConditions(0, BASE_DIST_INC);

function initBestSolution() {
	return { generation: 0, solution: new Individual() };
}

g_best_solution = initBestSolution();

let generation = 1;
window.onload = function()
{
	const canvas = document.getElementById('canvas');
	const ctx = canvas.getContext('2d');
	const canvas2 = document.getElementById('canvas2');
	const ctx2 = canvas2.getContext('2d');

	(function drawFrame () {
		window.requestAnimationFrame( drawFrame, canvas );
		ctx.clearRect( 0, 0, canvas.width, canvas.height );

		const endTime = new Date();
		const secondsElapsed = Math.trunc((endTime - g_start_time) / 1000);
		document.getElementById("RUNING_TIME_TEXT").innerHTML = "Running time: " + Math.trunc(secondsElapsed / 60)
			+ " min " + Math.trunc(secondsElapsed % 60) + " sec";

		document.getElementById("PROGRESS_TEXT").innerHTML = "Evaluating start condition "
			+ (g_current_start_condition + 1) + " / " + g_start_conditions.length;

		const halflife_factor = (g_mutation_halflife > 0)
			? Math.pow(2, -(generation % 1000) / g_mutation_halflife) : 1;
		const spread = Math.max(g_mutation_spread * halflife_factor, g_mutation_spread * 0.01);

		if(g_current_start_condition == 0) {
			g_population.clearFitnesses();
		}

		g_population.evaluate();

		let goToNextCondition = true;
		if(g_current_start_condition == g_start_conditions.length - 1) {
			generation += 1;

			const currentBest = g_population.evolve(spread);
			g_fitnessgraph.push( currentBest.fitnessToNumber() );

			if(true || generation == 2 || g_best_solution.solution.compareIndividuals(currentBest, g_best_solution.solution) < 0) {
				g_best_solution.generation = g_fitnessgraph.generation;
				g_best_solution.solution.copy(currentBest);
				document.getElementById("BEST_SOLUTION").innerHTML = "Best solution: fitness '"
					+ g_best_solution.solution.fitness.toString() + "' found at generation " + g_best_solution.generation;
				document.getElementById("BEST_SOLUTION_OUT").innerHTML = g_best_solution.solution.pilotNet.toText();
			}

			if(currentBest.solves >= g_start_conditions.length - 1) {
				const count = g_start_conditions.length;
				createStartConditions(count, BASE_DIST_INC, true);
				goToNextCondition = false;
				g_current_start_condition = 0;
			}

			ctx2.clearRect( 0, 0, canvas2.width, canvas2.height );
			g_visualizer.draw( ctx2 );
			for(let i = 0; i < currentBest.positions.length; ++i) {
				g_visualizer.drawPath( ctx2, currentBest.positions[i], CSS_COLOR_NAMES[i % CSS_COLOR_NAMES.length] );
			}
		}

		g_fitnessgraph.draw( ctx );

		if(goToNextCondition) {
			g_current_start_condition = ((g_current_start_condition + 1) % g_start_conditions.length);
		}

	}());
}

function onRestartButton()
{
	read_parameters();
	g_fitnessgraph.clear();
	generation = 1;
	g_population = makePopulation();
	g_best_solution = initBestSolution();
}

</script>
</body>
</html>
